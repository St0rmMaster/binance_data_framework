# План Разработки LeviafanDL: Универсального Фреймворка для Финансовых Данных

## Цель

Преобразовать существующую библиотеку в многофункциональный фреймворк, способный загружать данные из различных источников (Dukascopy, Binance), обрабатывать разные типы данных (тики, бары) и сохранять их в разнообразных хранилищах (локальный диск, Google Drive, FTP). Фреймворк должен быть адаптирован для работы как в Google Colab, так и в стандартных Python-окружениях (например, Windows/Linux), автоматически управляя конфигурацией и секретами.

## Ключевые архитектурные изменения

1.  **Принцип Источника Данных (Data Source):** Вместо монолитного коннектора будет введена абстракция "Источник данных". Каждый источник (Binance, Dukascopy) будет реализовывать общий интерфейс, что позволит системе гибко выбирать, откуда загружать данные, и упростит добавление новых источников в будущем.
2.  **Принцип Хранилища (Storage):** Логика сохранения данных будет отделена в абстракцию "Хранилище". Будут созданы сменные модули для сохранения данных локально (DuckDB/SQLite), на Google Drive и на FTP-сервере.
3.  **Менеджер Конфигурации (Config Manager):** Будет создан централизованный модуль для управления настройками и секретами. Он будет автоматически определять среду выполнения (Colab или локальная машина) и загружать учетные данные из соответствующего источника (`google.colab.userdata` или `.env` файл).
4.  **Приоритезация источников:** Для активов, доступных в нескольких источниках (например, криптовалюты), система будет автоматически применять логику приоритета: сначала попытка загрузки из Dukascopy, при неудаче — из Binance.

## Технологический стек

*   **Язык:** Python 3.9+
*   **Источники данных:**
    *   `dukascopy-python`: для данных от Dukascopy (Forex, CFD, товары).
    *   `python-binance`: для данных от Binance (криптовалюты).
*   **Обработка данных:** `pandas`.
*   **Хранилища:**
    *   `duckdb`: для высокопроизводительного локального хранения.
    *   `google-api-python-client`, `google-auth-httplib2`, `google-auth-oauthlib`: для интеграции с Google Drive.
    *   `ftplib` (стандартная библиотека Python): для работы с FTP.
*   **Конфигурация:** `python-dotenv`: для загрузки переменных окружения из `.env` файлов.
*   **Интерфейс в Colab:** `ipywidgets`.
*   **Утилиты:** `requests`, `datetime`, `lzma`.

---

## Шаги Разработки

### Шаг 1: Новая структура проекта и зависимости

1.  **Обновить зависимости:** Создать файл `requirements.txt` со всеми перечисленными библиотеками.
2.  **Изменить структуру папок:**
    ```
    LeviafanDL/
    ├── leviafan_dl/
    │   ├── __init__.py
    │   ├── sources/
    │   │   ├── __init__.py
    │   │   ├── base_source.py       # Абстрактный класс источника
    │   │   ├── dukascopy_source.py  # Реализация для Dukascopy
    │   │   └── binance_source.py    # Реализация для Binance
    │   ├── storage/
    │   │   ├── __init__.py
    │   │   ├── base_storage.py      # Абстрактный класс хранилища
    │   │   ├── local_storage.py     # Локальное хранилище (DuckDB)
    │   │   ├── gdrive_storage.py    # Хранилище Google Drive
    │   │   └── ftp_storage.py       # Хранилище FTP
    │   ├── core/
    │   │   ├── __init__.py
    │   │   ├── config_manager.py    # Менеджер конфигурации и секретов
    │   │   └── data_manager.py      # Главный менеджер, управляющий источниками и хранилищем
    │   └── ui/
    │       ├── __init__.py
    │       └── colab_interface.py   # UI для Colab
    ├── .env.example                 # Пример файла с переменными окружения
    ├── setup.py
    ├── README.md
    └── examples/
        └── usage_example.ipynb
    ```

### Шаг 2: Реализация Менеджера Конфигурации (`core/config_manager.py`)

*   **Класс `ConfigManager`:**
    *   В `__init__` определять среду (`is_colab = 'google.colab' in sys.modules`).
    *   **Метод `get_secret(key)`:**
        *   Если `is_colab`, пытается получить значение из `from google.colab import userdata; userdata.get(key)`.
        *   Иначе, использует `dotenv.load_dotenv()` и `os.getenv(key)`.
    *   **Метод `get_storage_path(storage_type)`:** Возвращает путь для хранения данных в зависимости от типа хранилища (локальный путь, ID папки в GDrive и т.д.).

### Шаг 3: Абстракция и реализация Источников Данных (`sources/`)

1.  **`base_source.py`:**
    *   **Абстрактный класс `BaseSource`:**
        *   Абстрактные методы: `get_data(symbol, start_date, end_date, timeframe)`, `get_ticks(symbol, start_date, end_date)`, `list_available_symbols()`.
2.  **`dukascopy_source.py`:**
    *   **Класс `DukascopySource(BaseSource)`:**
        *   Использует `dukascopy-python`.
        *   **Реализация `get_data`:** Загружает бары.
        *   **Реализация `get_ticks`:** Загружает тиковые данные.
        *   **Логика ресемплинга:** Если у пользователя уже есть тики, а он запрашивает бары, метод `get_data` должен сначала проверить наличие тиков в хранилище, и если они есть - ресемплировать их, а не загружать бары заново. Код для ресемплинга взять из `dukascopy_guide.md`.
3.  **`binance_source.py`:**
    *   **Класс `BinanceSource(BaseSource)`:**
        *   Перенести и адаптировать существующий код из `api_connector.py`.
        *   Метод `get_ticks` может возвращать `NotImplementedError`, так как Binance API (публичное) не отдает тики напрямую.

### Шаг 4: Абстракция и реализация Хранилищ Данных (`storage/`)

1.  **`base_storage.py`:**
    *   **Абстрактный класс `BaseStorage`:**
        *   Принимает в `__init__` путь к хранилищу.
        *   Абстрактные методы: `save(df, symbol, timeframe, data_type='bars')`, `load(symbol, timeframe, start_date, end_date, data_type='bars')`, `check_exists(symbol, timeframe, start_date, end_date, data_type='bars')`, `get_stored_info()`.
2.  **`local_storage.py`:**
    *   **Класс `LocalStorage(BaseStorage)`:**
        *   Адаптировать существующий код из `database_handler.py` для работы с DuckDB.
        *   Данные хранятся в отдельных таблицах или файлах Parquet в локальной директории.
3.  **`gdrive_storage.py`:**
    *   **Класс `GDriveStorage(BaseStorage)`:**
        *   Использует `google-api-python-client` для авторизации (через сервисный аккаунт или OAuth2 в Colab) и работы с файлами.
        *   Данные сохраняются как Parquet/CSV файлы в указанную папку на Google Drive.
4.  **`ftp_storage.py`:**
    *   **Класс `FTPStorage(BaseStorage)`:**
        *   Использует `ftplib` для подключения и передачи файлов.
        *   Данные сохраняются как Parquet/CSV файлы в указанную директорию на FTP-сервере.

### Шаг 5: Реализация Главного Менеджера (`core/data_manager.py`)

*   **Класс `DataManager`:**
    *   `__init__(storage_config, secrets_config)`:
        *   Инициализирует нужный класс хранилища (`LocalStorage`, `GDriveStorage` и т.д.) на основе `storage_config`.
        *   Инициализирует все источники данных (`DukascopySource`, `BinanceSource`).
    *   **Метод `fetch_data(symbol, start_date, end_date, timeframe)`:**
        *   **Логика выбора источника:**
            1. Проверить, поддерживает ли `DukascopySource` данный `symbol`.
            2. Если да, использовать его.
            3. Если нет, проверить `BinanceSource`.
            4. Если ни один не поддерживает, выдать ошибку.
        *   **Логика получения данных:**
            1. Вызвать `storage.check_exists` для проверки наличия данных.
            2. Определить недостающие диапазоны дат.
            3. Для недостающих диапазонов вызвать `source.get_data`.
            4. Сохранить новые данные с помощью `storage.save`.
            5. Загрузить полные данные за запрошенный период из хранилища и вернуть их.

### Шаг 6: Обновление UI (`ui/colab_interface.py`)

*   **Класс `DataDownloaderUI`:**
    *   `__init__` теперь принимает один объект - `DataManager`.
    *   **Обновить виджеты:**
        *   Добавить `Dropdown` для выбора типа хранилища: `['local', 'gdrive', 'ftp']`.
        *   Добавить `Text` поле для указания пути/ID папки.
        *   Добавить `Dropdown` для выбора типа данных: `['bars', 'ticks']`.
    *   **Обновить логику кнопок:**
        *   Кнопка "Загрузить" теперь просто вызывает `data_manager.fetch_data` с параметрами из виджетов. Вся сложная логика выбора источника и кэширования инкапсулирована внутри `DataManager`.

### Шаг 7: Финальная сборка и примеры

1.  **`leviafan_dl/__init__.py`:** Сделать удобные импорты, чтобы пользователь мог легко импортировать главные классы: `from leviafan_dl import DataManager, DataDownloaderUI`.
2.  **`examples/usage_example.ipynb`:**
    *   Показать, как настроить `.env` файл.
    *   Продемонстрировать инициализацию `DataManager` для каждого типа хранилища.
    *   Показать пример запуска `DataDownloaderUI`.
    *   Привести пример программного вызова `data_manager.fetch_data` для получения данных без UI.
    *   Показать пример загрузки данных по Форексу (EURUSD), акциям (AAPL.US) и криптовалюте (ETHBTC), демонстрируя автоматический выбор источника.

Этот план создает гибкую и расширяемую систему, отвечающую всем поставленным требованиям.